/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.7
 * source: nimar.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./google\\protobuf\\empty";
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export enum MessageType {
    MessageAgari = 0,
    MessageKyushuKyuhai = 1,
    MessageSukaikan = 2,
    MessageRyukyoku = 3
}
export enum Suit {
    NONE = 0,
    MANZU = 1,
    SOZU = 2,
    PINZU = 3,
    TON = 4,
    NAN = 5,
    SHA = 6,
    PE = 7,
    HAKU = 8,
    HATSU = 9,
    CHUN = 10
}
export enum Kaze {
    KAZE_TON = 0,
    KAZE_NAN = 2,
    KAZE_SHA = 3,
    KAZE_PE = 4
}
export enum OpenType {
    OPEN_NULL = 0,
    OPEN_PON = 1,
    OPEN_CHI = 2,
    OPEN_ANKAN = 3,
    OPEN_DAIMINKAN = 4,
    OPEN_KAKAN = 5,
    OPEN_PE = 6
}
export enum OperatorType {
    OPERATOR_START_GAME = 0,
    OPERATOR_SKIP = 1,
    OPERATOR_DRAW = 2,
    OPERATOR_DAHAI = 3,
    OPERATOR_RON = 4,
    OPERATOR_PON = 5,
    OPERATOR_CHI = 6,
    OPERATOR_DAIMINKAN = 7,
    OPERATOR_TSUMO = 8,
    OPERATOR_ANKAN = 9,
    OPERATOR_KAKAN = 10,
    OPERATOR_PE = 11,
    OPERATOR_KYUSHUKYUHAI = 12,
    OPERATOR_REACH = 13,
    OPERATOR_OK = 14
}
export class Yaku extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        name?: string;
        han?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("han" in data && data.han != undefined) {
                this.han = data.han;
            }
        }
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get han() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set han(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        name?: string;
        han?: number;
    }): Yaku {
        const message = new Yaku({});
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.han != null) {
            message.han = data.han;
        }
        return message;
    }
    toObject() {
        const data: {
            name?: string;
            han?: number;
        } = {};
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.han != null) {
            data.han = this.han;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.name.length)
            writer.writeString(1, this.name);
        if (this.han != 0)
            writer.writeInt64(2, this.han);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Yaku {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Yaku();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.name = reader.readString();
                    break;
                case 2:
                    message.han = reader.readInt64();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Yaku {
        return Yaku.deserialize(bytes);
    }
}
export class Point extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        totalHu?: number;
        totalHan?: number;
        totalPoint?: number;
        matchYakus?: Yaku[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("totalHu" in data && data.totalHu != undefined) {
                this.totalHu = data.totalHu;
            }
            if ("totalHan" in data && data.totalHan != undefined) {
                this.totalHan = data.totalHan;
            }
            if ("totalPoint" in data && data.totalPoint != undefined) {
                this.totalPoint = data.totalPoint;
            }
            if ("matchYakus" in data && data.matchYakus != undefined) {
                this.matchYakus = data.matchYakus;
            }
        }
    }
    get totalHu() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set totalHu(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get totalHan() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set totalHan(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get totalPoint() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set totalPoint(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get matchYakus() {
        return pb_1.Message.getRepeatedWrapperField(this, Yaku, 4) as Yaku[];
    }
    set matchYakus(value: Yaku[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    static fromObject(data: {
        totalHu?: number;
        totalHan?: number;
        totalPoint?: number;
        matchYakus?: ReturnType<typeof Yaku.prototype.toObject>[];
    }): Point {
        const message = new Point({});
        if (data.totalHu != null) {
            message.totalHu = data.totalHu;
        }
        if (data.totalHan != null) {
            message.totalHan = data.totalHan;
        }
        if (data.totalPoint != null) {
            message.totalPoint = data.totalPoint;
        }
        if (data.matchYakus != null) {
            message.matchYakus = data.matchYakus.map(item => Yaku.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            totalHu?: number;
            totalHan?: number;
            totalPoint?: number;
            matchYakus?: ReturnType<typeof Yaku.prototype.toObject>[];
        } = {};
        if (this.totalHu != null) {
            data.totalHu = this.totalHu;
        }
        if (this.totalHan != null) {
            data.totalHan = this.totalHan;
        }
        if (this.totalPoint != null) {
            data.totalPoint = this.totalPoint;
        }
        if (this.matchYakus != null) {
            data.matchYakus = this.matchYakus.map((item: Yaku) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.totalHu != 0)
            writer.writeInt64(1, this.totalHu);
        if (this.totalHan != 0)
            writer.writeInt64(2, this.totalHan);
        if (this.totalPoint != 0)
            writer.writeInt64(3, this.totalPoint);
        if (this.matchYakus.length)
            writer.writeRepeatedMessage(4, this.matchYakus, (item: Yaku) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Point {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Point();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.totalHu = reader.readInt64();
                    break;
                case 2:
                    message.totalHan = reader.readInt64();
                    break;
                case 3:
                    message.totalPoint = reader.readInt64();
                    break;
                case 4:
                    reader.readMessage(message.matchYakus, () => pb_1.Message.addToRepeatedWrapperField(message, 4, Yaku.deserialize(reader), Yaku));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Point {
        return Point.deserialize(bytes);
    }
}
export class Agari extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: string;
        name?: string;
        hand?: Tiles;
        tsumoriTile?: Tile;
        ronTile?: Tile;
        openedTile1?: OpenedTiles;
        openedTile2?: OpenedTiles;
        openedTile3?: OpenedTiles;
        openedTile4?: OpenedTiles;
        pe?: OpenedTiles;
        point?: Point;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("hand" in data && data.hand != undefined) {
                this.hand = data.hand;
            }
            if ("tsumoriTile" in data && data.tsumoriTile != undefined) {
                this.tsumoriTile = data.tsumoriTile;
            }
            if ("ronTile" in data && data.ronTile != undefined) {
                this.ronTile = data.ronTile;
            }
            if ("openedTile1" in data && data.openedTile1 != undefined) {
                this.openedTile1 = data.openedTile1;
            }
            if ("openedTile2" in data && data.openedTile2 != undefined) {
                this.openedTile2 = data.openedTile2;
            }
            if ("openedTile3" in data && data.openedTile3 != undefined) {
                this.openedTile3 = data.openedTile3;
            }
            if ("openedTile4" in data && data.openedTile4 != undefined) {
                this.openedTile4 = data.openedTile4;
            }
            if ("pe" in data && data.pe != undefined) {
                this.pe = data.pe;
            }
            if ("point" in data && data.point != undefined) {
                this.point = data.point;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get hand() {
        return pb_1.Message.getWrapperField(this, Tiles, 3) as Tiles;
    }
    set hand(value: Tiles) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_hand() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get tsumoriTile() {
        return pb_1.Message.getWrapperField(this, Tile, 4) as Tile;
    }
    set tsumoriTile(value: Tile) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_tsumoriTile() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get ronTile() {
        return pb_1.Message.getWrapperField(this, Tile, 5) as Tile;
    }
    set ronTile(value: Tile) {
        pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_ronTile() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get openedTile1() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 6) as OpenedTiles;
    }
    set openedTile1(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 6, value);
    }
    get has_openedTile1() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get openedTile2() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 7) as OpenedTiles;
    }
    set openedTile2(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 7, value);
    }
    get has_openedTile2() {
        return pb_1.Message.getField(this, 7) != null;
    }
    get openedTile3() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 8) as OpenedTiles;
    }
    set openedTile3(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 8, value);
    }
    get has_openedTile3() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get openedTile4() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 9) as OpenedTiles;
    }
    set openedTile4(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 9, value);
    }
    get has_openedTile4() {
        return pb_1.Message.getField(this, 9) != null;
    }
    get pe() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 10) as OpenedTiles;
    }
    set pe(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 10, value);
    }
    get has_pe() {
        return pb_1.Message.getField(this, 10) != null;
    }
    get point() {
        return pb_1.Message.getWrapperField(this, Point, 11) as Point;
    }
    set point(value: Point) {
        pb_1.Message.setWrapperField(this, 11, value);
    }
    get has_point() {
        return pb_1.Message.getField(this, 11) != null;
    }
    static fromObject(data: {
        id?: string;
        name?: string;
        hand?: ReturnType<typeof Tiles.prototype.toObject>;
        tsumoriTile?: ReturnType<typeof Tile.prototype.toObject>;
        ronTile?: ReturnType<typeof Tile.prototype.toObject>;
        openedTile1?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        openedTile2?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        openedTile3?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        openedTile4?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        pe?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        point?: ReturnType<typeof Point.prototype.toObject>;
    }): Agari {
        const message = new Agari({});
        if (data.id != null) {
            message.id = data.id;
        }
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.hand != null) {
            message.hand = Tiles.fromObject(data.hand);
        }
        if (data.tsumoriTile != null) {
            message.tsumoriTile = Tile.fromObject(data.tsumoriTile);
        }
        if (data.ronTile != null) {
            message.ronTile = Tile.fromObject(data.ronTile);
        }
        if (data.openedTile1 != null) {
            message.openedTile1 = OpenedTiles.fromObject(data.openedTile1);
        }
        if (data.openedTile2 != null) {
            message.openedTile2 = OpenedTiles.fromObject(data.openedTile2);
        }
        if (data.openedTile3 != null) {
            message.openedTile3 = OpenedTiles.fromObject(data.openedTile3);
        }
        if (data.openedTile4 != null) {
            message.openedTile4 = OpenedTiles.fromObject(data.openedTile4);
        }
        if (data.pe != null) {
            message.pe = OpenedTiles.fromObject(data.pe);
        }
        if (data.point != null) {
            message.point = Point.fromObject(data.point);
        }
        return message;
    }
    toObject() {
        const data: {
            id?: string;
            name?: string;
            hand?: ReturnType<typeof Tiles.prototype.toObject>;
            tsumoriTile?: ReturnType<typeof Tile.prototype.toObject>;
            ronTile?: ReturnType<typeof Tile.prototype.toObject>;
            openedTile1?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            openedTile2?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            openedTile3?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            openedTile4?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            pe?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            point?: ReturnType<typeof Point.prototype.toObject>;
        } = {};
        if (this.id != null) {
            data.id = this.id;
        }
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.hand != null) {
            data.hand = this.hand.toObject();
        }
        if (this.tsumoriTile != null) {
            data.tsumoriTile = this.tsumoriTile.toObject();
        }
        if (this.ronTile != null) {
            data.ronTile = this.ronTile.toObject();
        }
        if (this.openedTile1 != null) {
            data.openedTile1 = this.openedTile1.toObject();
        }
        if (this.openedTile2 != null) {
            data.openedTile2 = this.openedTile2.toObject();
        }
        if (this.openedTile3 != null) {
            data.openedTile3 = this.openedTile3.toObject();
        }
        if (this.openedTile4 != null) {
            data.openedTile4 = this.openedTile4.toObject();
        }
        if (this.pe != null) {
            data.pe = this.pe.toObject();
        }
        if (this.point != null) {
            data.point = this.point.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        if (this.name.length)
            writer.writeString(2, this.name);
        if (this.has_hand)
            writer.writeMessage(3, this.hand, () => this.hand.serialize(writer));
        if (this.has_tsumoriTile)
            writer.writeMessage(4, this.tsumoriTile, () => this.tsumoriTile.serialize(writer));
        if (this.has_ronTile)
            writer.writeMessage(5, this.ronTile, () => this.ronTile.serialize(writer));
        if (this.has_openedTile1)
            writer.writeMessage(6, this.openedTile1, () => this.openedTile1.serialize(writer));
        if (this.has_openedTile2)
            writer.writeMessage(7, this.openedTile2, () => this.openedTile2.serialize(writer));
        if (this.has_openedTile3)
            writer.writeMessage(8, this.openedTile3, () => this.openedTile3.serialize(writer));
        if (this.has_openedTile4)
            writer.writeMessage(9, this.openedTile4, () => this.openedTile4.serialize(writer));
        if (this.has_pe)
            writer.writeMessage(10, this.pe, () => this.pe.serialize(writer));
        if (this.has_point)
            writer.writeMessage(11, this.point, () => this.point.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Agari {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Agari();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                case 2:
                    message.name = reader.readString();
                    break;
                case 3:
                    reader.readMessage(message.hand, () => message.hand = Tiles.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.tsumoriTile, () => message.tsumoriTile = Tile.deserialize(reader));
                    break;
                case 5:
                    reader.readMessage(message.ronTile, () => message.ronTile = Tile.deserialize(reader));
                    break;
                case 6:
                    reader.readMessage(message.openedTile1, () => message.openedTile1 = OpenedTiles.deserialize(reader));
                    break;
                case 7:
                    reader.readMessage(message.openedTile2, () => message.openedTile2 = OpenedTiles.deserialize(reader));
                    break;
                case 8:
                    reader.readMessage(message.openedTile3, () => message.openedTile3 = OpenedTiles.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.openedTile4, () => message.openedTile4 = OpenedTiles.deserialize(reader));
                    break;
                case 10:
                    reader.readMessage(message.pe, () => message.pe = OpenedTiles.deserialize(reader));
                    break;
                case 11:
                    reader.readMessage(message.point, () => message.point = Point.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Agari {
        return Agari.deserialize(bytes);
    }
}
export class Message extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        messageType?: MessageType;
        agari?: Agari;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("messageType" in data && data.messageType != undefined) {
                this.messageType = data.messageType;
            }
            if ("agari" in data && data.agari != undefined) {
                this.agari = data.agari;
            }
        }
    }
    get messageType() {
        return pb_1.Message.getFieldWithDefault(this, 1, MessageType.MessageAgari) as MessageType;
    }
    set messageType(value: MessageType) {
        pb_1.Message.setField(this, 1, value);
    }
    get agari() {
        return pb_1.Message.getWrapperField(this, Agari, 2) as Agari;
    }
    set agari(value: Agari) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_agari() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        messageType?: MessageType;
        agari?: ReturnType<typeof Agari.prototype.toObject>;
    }): Message {
        const message = new Message({});
        if (data.messageType != null) {
            message.messageType = data.messageType;
        }
        if (data.agari != null) {
            message.agari = Agari.fromObject(data.agari);
        }
        return message;
    }
    toObject() {
        const data: {
            messageType?: MessageType;
            agari?: ReturnType<typeof Agari.prototype.toObject>;
        } = {};
        if (this.messageType != null) {
            data.messageType = this.messageType;
        }
        if (this.agari != null) {
            data.agari = this.agari.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.messageType != MessageType.MessageAgari)
            writer.writeEnum(1, this.messageType);
        if (this.has_agari)
            writer.writeMessage(2, this.agari, () => this.agari.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Message {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Message();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.messageType = reader.readEnum();
                    break;
                case 2:
                    reader.readMessage(message.agari, () => message.agari = Agari.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Message {
        return Message.deserialize(bytes);
    }
}
export class CreateRoomRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        roomName?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("roomName" in data && data.roomName != undefined) {
                this.roomName = data.roomName;
            }
        }
    }
    get roomName() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set roomName(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        roomName?: string;
    }): CreateRoomRequest {
        const message = new CreateRoomRequest({});
        if (data.roomName != null) {
            message.roomName = data.roomName;
        }
        return message;
    }
    toObject() {
        const data: {
            roomName?: string;
        } = {};
        if (this.roomName != null) {
            data.roomName = this.roomName;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.roomName.length)
            writer.writeString(1, this.roomName);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateRoomRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateRoomRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.roomName = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CreateRoomRequest {
        return CreateRoomRequest.deserialize(bytes);
    }
}
export class Room extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        roomID?: string;
        roomName?: string;
        playerNames?: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("roomID" in data && data.roomID != undefined) {
                this.roomID = data.roomID;
            }
            if ("roomName" in data && data.roomName != undefined) {
                this.roomName = data.roomName;
            }
            if ("playerNames" in data && data.playerNames != undefined) {
                this.playerNames = data.playerNames;
            }
        }
    }
    get roomID() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set roomID(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get roomName() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set roomName(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get playerNames() {
        return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
    }
    set playerNames(value: string[]) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        roomID?: string;
        roomName?: string;
        playerNames?: string[];
    }): Room {
        const message = new Room({});
        if (data.roomID != null) {
            message.roomID = data.roomID;
        }
        if (data.roomName != null) {
            message.roomName = data.roomName;
        }
        if (data.playerNames != null) {
            message.playerNames = data.playerNames;
        }
        return message;
    }
    toObject() {
        const data: {
            roomID?: string;
            roomName?: string;
            playerNames?: string[];
        } = {};
        if (this.roomID != null) {
            data.roomID = this.roomID;
        }
        if (this.roomName != null) {
            data.roomName = this.roomName;
        }
        if (this.playerNames != null) {
            data.playerNames = this.playerNames;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.roomID.length)
            writer.writeString(1, this.roomID);
        if (this.roomName.length)
            writer.writeString(2, this.roomName);
        if (this.playerNames.length)
            writer.writeRepeatedString(3, this.playerNames);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Room {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Room();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.roomID = reader.readString();
                    break;
                case 2:
                    message.roomName = reader.readString();
                    break;
                case 3:
                    pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Room {
        return Room.deserialize(bytes);
    }
}
export class Rooms extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        rooms?: Room[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("rooms" in data && data.rooms != undefined) {
                this.rooms = data.rooms;
            }
        }
    }
    get rooms() {
        return pb_1.Message.getRepeatedWrapperField(this, Room, 1) as Room[];
    }
    set rooms(value: Room[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        rooms?: ReturnType<typeof Room.prototype.toObject>[];
    }): Rooms {
        const message = new Rooms({});
        if (data.rooms != null) {
            message.rooms = data.rooms.map(item => Room.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            rooms?: ReturnType<typeof Room.prototype.toObject>[];
        } = {};
        if (this.rooms != null) {
            data.rooms = this.rooms.map((item: Room) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.rooms.length)
            writer.writeRepeatedMessage(1, this.rooms, (item: Room) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Rooms {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Rooms();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.rooms, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Room.deserialize(reader), Room));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Rooms {
        return Rooms.deserialize(bytes);
    }
}
export class JoinRoomRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        playerID?: string;
        playerName?: string;
        roomID?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("playerID" in data && data.playerID != undefined) {
                this.playerID = data.playerID;
            }
            if ("playerName" in data && data.playerName != undefined) {
                this.playerName = data.playerName;
            }
            if ("roomID" in data && data.roomID != undefined) {
                this.roomID = data.roomID;
            }
        }
    }
    get playerID() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set playerID(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get playerName() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set playerName(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get roomID() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set roomID(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        playerID?: string;
        playerName?: string;
        roomID?: string;
    }): JoinRoomRequest {
        const message = new JoinRoomRequest({});
        if (data.playerID != null) {
            message.playerID = data.playerID;
        }
        if (data.playerName != null) {
            message.playerName = data.playerName;
        }
        if (data.roomID != null) {
            message.roomID = data.roomID;
        }
        return message;
    }
    toObject() {
        const data: {
            playerID?: string;
            playerName?: string;
            roomID?: string;
        } = {};
        if (this.playerID != null) {
            data.playerID = this.playerID;
        }
        if (this.playerName != null) {
            data.playerName = this.playerName;
        }
        if (this.roomID != null) {
            data.roomID = this.roomID;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.playerID.length)
            writer.writeString(1, this.playerID);
        if (this.playerName.length)
            writer.writeString(2, this.playerName);
        if (this.roomID.length)
            writer.writeString(3, this.roomID);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): JoinRoomRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new JoinRoomRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.playerID = reader.readString();
                    break;
                case 2:
                    message.playerName = reader.readString();
                    break;
                case 3:
                    message.roomID = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): JoinRoomRequest {
        return JoinRoomRequest.deserialize(bytes);
    }
}
export class TableStatus extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        kaze?: Kaze;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("kaze" in data && data.kaze != undefined) {
                this.kaze = data.kaze;
            }
        }
    }
    get kaze() {
        return pb_1.Message.getFieldWithDefault(this, 1, Kaze.KAZE_TON) as Kaze;
    }
    set kaze(value: Kaze) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        kaze?: Kaze;
    }): TableStatus {
        const message = new TableStatus({});
        if (data.kaze != null) {
            message.kaze = data.kaze;
        }
        return message;
    }
    toObject() {
        const data: {
            kaze?: Kaze;
        } = {};
        if (this.kaze != null) {
            data.kaze = this.kaze;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.kaze != Kaze.KAZE_TON)
            writer.writeEnum(1, this.kaze);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TableStatus {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TableStatus();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.kaze = reader.readEnum();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TableStatus {
        return TableStatus.deserialize(bytes);
    }
}
export class GameTable extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        tsumo?: Tsumo;
        player1?: Player;
        player2?: Player;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("tsumo" in data && data.tsumo != undefined) {
                this.tsumo = data.tsumo;
            }
            if ("player1" in data && data.player1 != undefined) {
                this.player1 = data.player1;
            }
            if ("player2" in data && data.player2 != undefined) {
                this.player2 = data.player2;
            }
        }
    }
    get tsumo() {
        return pb_1.Message.getWrapperField(this, Tsumo, 1) as Tsumo;
    }
    set tsumo(value: Tsumo) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_tsumo() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get player1() {
        return pb_1.Message.getWrapperField(this, Player, 2) as Player;
    }
    set player1(value: Player) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_player1() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get player2() {
        return pb_1.Message.getWrapperField(this, Player, 3) as Player;
    }
    set player2(value: Player) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_player2() {
        return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
        tsumo?: ReturnType<typeof Tsumo.prototype.toObject>;
        player1?: ReturnType<typeof Player.prototype.toObject>;
        player2?: ReturnType<typeof Player.prototype.toObject>;
    }): GameTable {
        const message = new GameTable({});
        if (data.tsumo != null) {
            message.tsumo = Tsumo.fromObject(data.tsumo);
        }
        if (data.player1 != null) {
            message.player1 = Player.fromObject(data.player1);
        }
        if (data.player2 != null) {
            message.player2 = Player.fromObject(data.player2);
        }
        return message;
    }
    toObject() {
        const data: {
            tsumo?: ReturnType<typeof Tsumo.prototype.toObject>;
            player1?: ReturnType<typeof Player.prototype.toObject>;
            player2?: ReturnType<typeof Player.prototype.toObject>;
        } = {};
        if (this.tsumo != null) {
            data.tsumo = this.tsumo.toObject();
        }
        if (this.player1 != null) {
            data.player1 = this.player1.toObject();
        }
        if (this.player2 != null) {
            data.player2 = this.player2.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_tsumo)
            writer.writeMessage(1, this.tsumo, () => this.tsumo.serialize(writer));
        if (this.has_player1)
            writer.writeMessage(2, this.player1, () => this.player1.serialize(writer));
        if (this.has_player2)
            writer.writeMessage(3, this.player2, () => this.player2.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GameTable {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GameTable();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.tsumo, () => message.tsumo = Tsumo.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.player1, () => message.player1 = Player.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.player2, () => message.player2 = Player.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GameTable {
        return GameTable.deserialize(bytes);
    }
}
export class Tsumo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        tiles?: Tiles;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("tiles" in data && data.tiles != undefined) {
                this.tiles = data.tiles;
            }
        }
    }
    get tiles() {
        return pb_1.Message.getWrapperField(this, Tiles, 1) as Tiles;
    }
    set tiles(value: Tiles) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_tiles() {
        return pb_1.Message.getField(this, 1) != null;
    }
    static fromObject(data: {
        tiles?: ReturnType<typeof Tiles.prototype.toObject>;
    }): Tsumo {
        const message = new Tsumo({});
        if (data.tiles != null) {
            message.tiles = Tiles.fromObject(data.tiles);
        }
        return message;
    }
    toObject() {
        const data: {
            tiles?: ReturnType<typeof Tiles.prototype.toObject>;
        } = {};
        if (this.tiles != null) {
            data.tiles = this.tiles.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_tiles)
            writer.writeMessage(1, this.tiles, () => this.tiles.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tsumo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tsumo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.tiles, () => message.tiles = Tiles.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Tsumo {
        return Tsumo.deserialize(bytes);
    }
}
export class Tiles extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        tiles?: Tile[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("tiles" in data && data.tiles != undefined) {
                this.tiles = data.tiles;
            }
        }
    }
    get tiles() {
        return pb_1.Message.getRepeatedWrapperField(this, Tile, 1) as Tile[];
    }
    set tiles(value: Tile[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        tiles?: ReturnType<typeof Tile.prototype.toObject>[];
    }): Tiles {
        const message = new Tiles({});
        if (data.tiles != null) {
            message.tiles = data.tiles.map(item => Tile.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            tiles?: ReturnType<typeof Tile.prototype.toObject>[];
        } = {};
        if (this.tiles != null) {
            data.tiles = this.tiles.map((item: Tile) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.tiles.length)
            writer.writeRepeatedMessage(1, this.tiles, (item: Tile) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tiles {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tiles();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.tiles, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Tile.deserialize(reader), Tile));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Tiles {
        return Tiles.deserialize(bytes);
    }
}
export class Tile extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: number;
        name?: string;
        num?: number;
        suit?: Suit;
        dora?: boolean;
        akadora?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("num" in data && data.num != undefined) {
                this.num = data.num;
            }
            if ("suit" in data && data.suit != undefined) {
                this.suit = data.suit;
            }
            if ("dora" in data && data.dora != undefined) {
                this.dora = data.dora;
            }
            if ("akadora" in data && data.akadora != undefined) {
                this.akadora = data.akadora;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set id(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get num() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set num(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get suit() {
        return pb_1.Message.getFieldWithDefault(this, 4, Suit.NONE) as Suit;
    }
    set suit(value: Suit) {
        pb_1.Message.setField(this, 4, value);
    }
    get dora() {
        return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
    }
    set dora(value: boolean) {
        pb_1.Message.setField(this, 5, value);
    }
    get akadora() {
        return pb_1.Message.getFieldWithDefault(this, 6, false) as boolean;
    }
    set akadora(value: boolean) {
        pb_1.Message.setField(this, 6, value);
    }
    static fromObject(data: {
        id?: number;
        name?: string;
        num?: number;
        suit?: Suit;
        dora?: boolean;
        akadora?: boolean;
    }): Tile {
        const message = new Tile({});
        if (data.id != null) {
            message.id = data.id;
        }
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.num != null) {
            message.num = data.num;
        }
        if (data.suit != null) {
            message.suit = data.suit;
        }
        if (data.dora != null) {
            message.dora = data.dora;
        }
        if (data.akadora != null) {
            message.akadora = data.akadora;
        }
        return message;
    }
    toObject() {
        const data: {
            id?: number;
            name?: string;
            num?: number;
            suit?: Suit;
            dora?: boolean;
            akadora?: boolean;
        } = {};
        if (this.id != null) {
            data.id = this.id;
        }
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.num != null) {
            data.num = this.num;
        }
        if (this.suit != null) {
            data.suit = this.suit;
        }
        if (this.dora != null) {
            data.dora = this.dora;
        }
        if (this.akadora != null) {
            data.akadora = this.akadora;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id != 0)
            writer.writeInt64(1, this.id);
        if (this.name.length)
            writer.writeString(2, this.name);
        if (this.num != 0)
            writer.writeInt64(3, this.num);
        if (this.suit != Suit.NONE)
            writer.writeEnum(4, this.suit);
        if (this.dora != false)
            writer.writeBool(5, this.dora);
        if (this.akadora != false)
            writer.writeBool(6, this.akadora);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tile {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tile();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readInt64();
                    break;
                case 2:
                    message.name = reader.readString();
                    break;
                case 3:
                    message.num = reader.readInt64();
                    break;
                case 4:
                    message.suit = reader.readEnum();
                    break;
                case 5:
                    message.dora = reader.readBool();
                    break;
                case 6:
                    message.akadora = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Tile {
        return Tile.deserialize(bytes);
    }
}
export class Player extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: string;
        name?: string;
        hand?: Tiles;
        tsumoriTile?: Tile;
        openedTile1?: OpenedTiles;
        openedTile2?: OpenedTiles;
        openedTile3?: OpenedTiles;
        openedTile4?: OpenedTiles;
        pe?: OpenedTiles;
        kawa?: Tiles;
        kaze?: Kaze;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
            if ("name" in data && data.name != undefined) {
                this.name = data.name;
            }
            if ("hand" in data && data.hand != undefined) {
                this.hand = data.hand;
            }
            if ("tsumoriTile" in data && data.tsumoriTile != undefined) {
                this.tsumoriTile = data.tsumoriTile;
            }
            if ("openedTile1" in data && data.openedTile1 != undefined) {
                this.openedTile1 = data.openedTile1;
            }
            if ("openedTile2" in data && data.openedTile2 != undefined) {
                this.openedTile2 = data.openedTile2;
            }
            if ("openedTile3" in data && data.openedTile3 != undefined) {
                this.openedTile3 = data.openedTile3;
            }
            if ("openedTile4" in data && data.openedTile4 != undefined) {
                this.openedTile4 = data.openedTile4;
            }
            if ("pe" in data && data.pe != undefined) {
                this.pe = data.pe;
            }
            if ("kawa" in data && data.kawa != undefined) {
                this.kawa = data.kawa;
            }
            if ("kaze" in data && data.kaze != undefined) {
                this.kaze = data.kaze;
            }
        }
    }
    get id() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set id(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get name() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set name(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get hand() {
        return pb_1.Message.getWrapperField(this, Tiles, 3) as Tiles;
    }
    set hand(value: Tiles) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_hand() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get tsumoriTile() {
        return pb_1.Message.getWrapperField(this, Tile, 4) as Tile;
    }
    set tsumoriTile(value: Tile) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_tsumoriTile() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get openedTile1() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 5) as OpenedTiles;
    }
    set openedTile1(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 5, value);
    }
    get has_openedTile1() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get openedTile2() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 6) as OpenedTiles;
    }
    set openedTile2(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 6, value);
    }
    get has_openedTile2() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get openedTile3() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 7) as OpenedTiles;
    }
    set openedTile3(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 7, value);
    }
    get has_openedTile3() {
        return pb_1.Message.getField(this, 7) != null;
    }
    get openedTile4() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 8) as OpenedTiles;
    }
    set openedTile4(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 8, value);
    }
    get has_openedTile4() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get pe() {
        return pb_1.Message.getWrapperField(this, OpenedTiles, 9) as OpenedTiles;
    }
    set pe(value: OpenedTiles) {
        pb_1.Message.setWrapperField(this, 9, value);
    }
    get has_pe() {
        return pb_1.Message.getField(this, 9) != null;
    }
    get kawa() {
        return pb_1.Message.getWrapperField(this, Tiles, 10) as Tiles;
    }
    set kawa(value: Tiles) {
        pb_1.Message.setWrapperField(this, 10, value);
    }
    get has_kawa() {
        return pb_1.Message.getField(this, 10) != null;
    }
    get kaze() {
        return pb_1.Message.getFieldWithDefault(this, 11, Kaze.KAZE_TON) as Kaze;
    }
    set kaze(value: Kaze) {
        pb_1.Message.setField(this, 11, value);
    }
    static fromObject(data: {
        id?: string;
        name?: string;
        hand?: ReturnType<typeof Tiles.prototype.toObject>;
        tsumoriTile?: ReturnType<typeof Tile.prototype.toObject>;
        openedTile1?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        openedTile2?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        openedTile3?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        openedTile4?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        pe?: ReturnType<typeof OpenedTiles.prototype.toObject>;
        kawa?: ReturnType<typeof Tiles.prototype.toObject>;
        kaze?: Kaze;
    }): Player {
        const message = new Player({});
        if (data.id != null) {
            message.id = data.id;
        }
        if (data.name != null) {
            message.name = data.name;
        }
        if (data.hand != null) {
            message.hand = Tiles.fromObject(data.hand);
        }
        if (data.tsumoriTile != null) {
            message.tsumoriTile = Tile.fromObject(data.tsumoriTile);
        }
        if (data.openedTile1 != null) {
            message.openedTile1 = OpenedTiles.fromObject(data.openedTile1);
        }
        if (data.openedTile2 != null) {
            message.openedTile2 = OpenedTiles.fromObject(data.openedTile2);
        }
        if (data.openedTile3 != null) {
            message.openedTile3 = OpenedTiles.fromObject(data.openedTile3);
        }
        if (data.openedTile4 != null) {
            message.openedTile4 = OpenedTiles.fromObject(data.openedTile4);
        }
        if (data.pe != null) {
            message.pe = OpenedTiles.fromObject(data.pe);
        }
        if (data.kawa != null) {
            message.kawa = Tiles.fromObject(data.kawa);
        }
        if (data.kaze != null) {
            message.kaze = data.kaze;
        }
        return message;
    }
    toObject() {
        const data: {
            id?: string;
            name?: string;
            hand?: ReturnType<typeof Tiles.prototype.toObject>;
            tsumoriTile?: ReturnType<typeof Tile.prototype.toObject>;
            openedTile1?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            openedTile2?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            openedTile3?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            openedTile4?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            pe?: ReturnType<typeof OpenedTiles.prototype.toObject>;
            kawa?: ReturnType<typeof Tiles.prototype.toObject>;
            kaze?: Kaze;
        } = {};
        if (this.id != null) {
            data.id = this.id;
        }
        if (this.name != null) {
            data.name = this.name;
        }
        if (this.hand != null) {
            data.hand = this.hand.toObject();
        }
        if (this.tsumoriTile != null) {
            data.tsumoriTile = this.tsumoriTile.toObject();
        }
        if (this.openedTile1 != null) {
            data.openedTile1 = this.openedTile1.toObject();
        }
        if (this.openedTile2 != null) {
            data.openedTile2 = this.openedTile2.toObject();
        }
        if (this.openedTile3 != null) {
            data.openedTile3 = this.openedTile3.toObject();
        }
        if (this.openedTile4 != null) {
            data.openedTile4 = this.openedTile4.toObject();
        }
        if (this.pe != null) {
            data.pe = this.pe.toObject();
        }
        if (this.kawa != null) {
            data.kawa = this.kawa.toObject();
        }
        if (this.kaze != null) {
            data.kaze = this.kaze;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.id.length)
            writer.writeString(1, this.id);
        if (this.name.length)
            writer.writeString(2, this.name);
        if (this.has_hand)
            writer.writeMessage(3, this.hand, () => this.hand.serialize(writer));
        if (this.has_tsumoriTile)
            writer.writeMessage(4, this.tsumoriTile, () => this.tsumoriTile.serialize(writer));
        if (this.has_openedTile1)
            writer.writeMessage(5, this.openedTile1, () => this.openedTile1.serialize(writer));
        if (this.has_openedTile2)
            writer.writeMessage(6, this.openedTile2, () => this.openedTile2.serialize(writer));
        if (this.has_openedTile3)
            writer.writeMessage(7, this.openedTile3, () => this.openedTile3.serialize(writer));
        if (this.has_openedTile4)
            writer.writeMessage(8, this.openedTile4, () => this.openedTile4.serialize(writer));
        if (this.has_pe)
            writer.writeMessage(9, this.pe, () => this.pe.serialize(writer));
        if (this.has_kawa)
            writer.writeMessage(10, this.kawa, () => this.kawa.serialize(writer));
        if (this.kaze != Kaze.KAZE_TON)
            writer.writeEnum(11, this.kaze);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Player {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Player();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.id = reader.readString();
                    break;
                case 2:
                    message.name = reader.readString();
                    break;
                case 3:
                    reader.readMessage(message.hand, () => message.hand = Tiles.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.tsumoriTile, () => message.tsumoriTile = Tile.deserialize(reader));
                    break;
                case 5:
                    reader.readMessage(message.openedTile1, () => message.openedTile1 = OpenedTiles.deserialize(reader));
                    break;
                case 6:
                    reader.readMessage(message.openedTile2, () => message.openedTile2 = OpenedTiles.deserialize(reader));
                    break;
                case 7:
                    reader.readMessage(message.openedTile3, () => message.openedTile3 = OpenedTiles.deserialize(reader));
                    break;
                case 8:
                    reader.readMessage(message.openedTile4, () => message.openedTile4 = OpenedTiles.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.pe, () => message.pe = OpenedTiles.deserialize(reader));
                    break;
                case 10:
                    reader.readMessage(message.kawa, () => message.kawa = Tiles.deserialize(reader));
                    break;
                case 11:
                    message.kaze = reader.readEnum();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Player {
        return Player.deserialize(bytes);
    }
}
export class OpenedTiles extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        openType?: OpenType;
        tiles?: Tiles;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("openType" in data && data.openType != undefined) {
                this.openType = data.openType;
            }
            if ("tiles" in data && data.tiles != undefined) {
                this.tiles = data.tiles;
            }
        }
    }
    get openType() {
        return pb_1.Message.getFieldWithDefault(this, 1, OpenType.OPEN_NULL) as OpenType;
    }
    set openType(value: OpenType) {
        pb_1.Message.setField(this, 1, value);
    }
    get tiles() {
        return pb_1.Message.getWrapperField(this, Tiles, 2) as Tiles;
    }
    set tiles(value: Tiles) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_tiles() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        openType?: OpenType;
        tiles?: ReturnType<typeof Tiles.prototype.toObject>;
    }): OpenedTiles {
        const message = new OpenedTiles({});
        if (data.openType != null) {
            message.openType = data.openType;
        }
        if (data.tiles != null) {
            message.tiles = Tiles.fromObject(data.tiles);
        }
        return message;
    }
    toObject() {
        const data: {
            openType?: OpenType;
            tiles?: ReturnType<typeof Tiles.prototype.toObject>;
        } = {};
        if (this.openType != null) {
            data.openType = this.openType;
        }
        if (this.tiles != null) {
            data.tiles = this.tiles.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.openType != OpenType.OPEN_NULL)
            writer.writeEnum(1, this.openType);
        if (this.has_tiles)
            writer.writeMessage(2, this.tiles, () => this.tiles.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OpenedTiles {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OpenedTiles();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.openType = reader.readEnum();
                    break;
                case 2:
                    reader.readMessage(message.tiles, () => message.tiles = Tiles.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OpenedTiles {
        return OpenedTiles.deserialize(bytes);
    }
}
export class PlayerID extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        playerid?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("playerid" in data && data.playerid != undefined) {
                this.playerid = data.playerid;
            }
        }
    }
    get playerid() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set playerid(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        playerid?: string;
    }): PlayerID {
        const message = new PlayerID({});
        if (data.playerid != null) {
            message.playerid = data.playerid;
        }
        return message;
    }
    toObject() {
        const data: {
            playerid?: string;
        } = {};
        if (this.playerid != null) {
            data.playerid = this.playerid;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.playerid.length)
            writer.writeString(1, this.playerid);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PlayerID {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PlayerID();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.playerid = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PlayerID {
        return PlayerID.deserialize(bytes);
    }
}
export class Operators extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        operators?: Operator[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("operators" in data && data.operators != undefined) {
                this.operators = data.operators;
            }
        }
    }
    get operators() {
        return pb_1.Message.getRepeatedWrapperField(this, Operator, 2) as Operator[];
    }
    set operators(value: Operator[]) {
        pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
        operators?: ReturnType<typeof Operator.prototype.toObject>[];
    }): Operators {
        const message = new Operators({});
        if (data.operators != null) {
            message.operators = data.operators.map(item => Operator.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            operators?: ReturnType<typeof Operator.prototype.toObject>[];
        } = {};
        if (this.operators != null) {
            data.operators = this.operators.map((item: Operator) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.operators.length)
            writer.writeRepeatedMessage(2, this.operators, (item: Operator) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Operators {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Operators();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 2:
                    reader.readMessage(message.operators, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Operator.deserialize(reader), Operator));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Operators {
        return Operators.deserialize(bytes);
    }
}
export class Operator extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        roomID?: string;
        playerID?: string;
        operatorType?: OperatorType;
        targetTiles?: Tiles;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("roomID" in data && data.roomID != undefined) {
                this.roomID = data.roomID;
            }
            if ("playerID" in data && data.playerID != undefined) {
                this.playerID = data.playerID;
            }
            if ("operatorType" in data && data.operatorType != undefined) {
                this.operatorType = data.operatorType;
            }
            if ("targetTiles" in data && data.targetTiles != undefined) {
                this.targetTiles = data.targetTiles;
            }
        }
    }
    get roomID() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set roomID(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get playerID() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set playerID(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get operatorType() {
        return pb_1.Message.getFieldWithDefault(this, 3, OperatorType.OPERATOR_START_GAME) as OperatorType;
    }
    set operatorType(value: OperatorType) {
        pb_1.Message.setField(this, 3, value);
    }
    get targetTiles() {
        return pb_1.Message.getWrapperField(this, Tiles, 4) as Tiles;
    }
    set targetTiles(value: Tiles) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get has_targetTiles() {
        return pb_1.Message.getField(this, 4) != null;
    }
    static fromObject(data: {
        roomID?: string;
        playerID?: string;
        operatorType?: OperatorType;
        targetTiles?: ReturnType<typeof Tiles.prototype.toObject>;
    }): Operator {
        const message = new Operator({});
        if (data.roomID != null) {
            message.roomID = data.roomID;
        }
        if (data.playerID != null) {
            message.playerID = data.playerID;
        }
        if (data.operatorType != null) {
            message.operatorType = data.operatorType;
        }
        if (data.targetTiles != null) {
            message.targetTiles = Tiles.fromObject(data.targetTiles);
        }
        return message;
    }
    toObject() {
        const data: {
            roomID?: string;
            playerID?: string;
            operatorType?: OperatorType;
            targetTiles?: ReturnType<typeof Tiles.prototype.toObject>;
        } = {};
        if (this.roomID != null) {
            data.roomID = this.roomID;
        }
        if (this.playerID != null) {
            data.playerID = this.playerID;
        }
        if (this.operatorType != null) {
            data.operatorType = this.operatorType;
        }
        if (this.targetTiles != null) {
            data.targetTiles = this.targetTiles.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.roomID.length)
            writer.writeString(1, this.roomID);
        if (this.playerID.length)
            writer.writeString(2, this.playerID);
        if (this.operatorType != OperatorType.OPERATOR_START_GAME)
            writer.writeEnum(3, this.operatorType);
        if (this.has_targetTiles)
            writer.writeMessage(4, this.targetTiles, () => this.targetTiles.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Operator {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Operator();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.roomID = reader.readString();
                    break;
                case 2:
                    message.playerID = reader.readString();
                    break;
                case 3:
                    message.operatorType = reader.readEnum();
                    break;
                case 4:
                    reader.readMessage(message.targetTiles, () => message.targetTiles = Tiles.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Operator {
        return Operator.deserialize(bytes);
    }
}
interface GrpcUnaryServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
}
interface GrpcStreamServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
}
interface GrpWritableServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
}
interface GrpcChunkServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
}
interface GrpcPromiseServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
    (message: P, options?: grpc_1.CallOptions): Promise<R>;
}
export abstract class UnimplementedNimaRService {
    static definition = {
        ListRooms: {
            path: "/NimaR/ListRooms",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: dependency_1.google.protobuf.Empty) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => dependency_1.google.protobuf.Empty.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: Rooms) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => Rooms.deserialize(new Uint8Array(bytes))
        },
        CreateRoom: {
            path: "/NimaR/CreateRoom",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: CreateRoomRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => CreateRoomRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: Room) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => Room.deserialize(new Uint8Array(bytes))
        },
        GameTableStream: {
            path: "/NimaR/GameTableStream",
            requestStream: false,
            responseStream: true,
            requestSerialize: (message: JoinRoomRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => JoinRoomRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: GameTable) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => GameTable.deserialize(new Uint8Array(bytes))
        },
        GetPlayerID: {
            path: "/NimaR/GetPlayerID",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: dependency_1.google.protobuf.Empty) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => dependency_1.google.protobuf.Empty.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: PlayerID) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => PlayerID.deserialize(new Uint8Array(bytes))
        },
        MessageStream: {
            path: "/NimaR/MessageStream",
            requestStream: false,
            responseStream: true,
            requestSerialize: (message: JoinRoomRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => JoinRoomRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: Message) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => Message.deserialize(new Uint8Array(bytes))
        },
        OperatorsStream: {
            path: "/NimaR/OperatorsStream",
            requestStream: false,
            responseStream: true,
            requestSerialize: (message: JoinRoomRequest) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => JoinRoomRequest.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: Operators) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => Operators.deserialize(new Uint8Array(bytes))
        },
        Operate: {
            path: "/NimaR/Operate",
            requestStream: false,
            responseStream: false,
            requestSerialize: (message: Operator) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => Operator.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: dependency_1.google.protobuf.Empty) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => dependency_1.google.protobuf.Empty.deserialize(new Uint8Array(bytes))
        }
    };
    [method: string]: grpc_1.UntypedHandleCall;
    abstract ListRooms(call: grpc_1.ServerUnaryCall<dependency_1.google.protobuf.Empty, Rooms>, callback: grpc_1.sendUnaryData<Rooms>): void;
    abstract CreateRoom(call: grpc_1.ServerUnaryCall<CreateRoomRequest, Room>, callback: grpc_1.sendUnaryData<Room>): void;
    abstract GameTableStream(call: grpc_1.ServerWritableStream<JoinRoomRequest, GameTable>): void;
    abstract GetPlayerID(call: grpc_1.ServerUnaryCall<dependency_1.google.protobuf.Empty, PlayerID>, callback: grpc_1.sendUnaryData<PlayerID>): void;
    abstract MessageStream(call: grpc_1.ServerWritableStream<JoinRoomRequest, Message>): void;
    abstract OperatorsStream(call: grpc_1.ServerWritableStream<JoinRoomRequest, Operators>): void;
    abstract Operate(call: grpc_1.ServerUnaryCall<Operator, dependency_1.google.protobuf.Empty>, callback: grpc_1.sendUnaryData<dependency_1.google.protobuf.Empty>): void;
}
export class NimaRClient extends grpc_1.makeGenericClientConstructor(UnimplementedNimaRService.definition, "NimaR", {}) {
    constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
        super(address, credentials, options);
    }
    ListRooms: GrpcUnaryServiceInterface<dependency_1.google.protobuf.Empty, Rooms> = (message: dependency_1.google.protobuf.Empty, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Rooms>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Rooms>, callback?: grpc_1.requestCallback<Rooms>): grpc_1.ClientUnaryCall => {
        return super.ListRooms(message, metadata, options, callback);
    };
    CreateRoom: GrpcUnaryServiceInterface<CreateRoomRequest, Room> = (message: CreateRoomRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Room>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Room>, callback?: grpc_1.requestCallback<Room>): grpc_1.ClientUnaryCall => {
        return super.CreateRoom(message, metadata, options, callback);
    };
    GameTableStream: GrpcStreamServiceInterface<JoinRoomRequest, JoinRoomRequest> = (message: JoinRoomRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<JoinRoomRequest> => {
        return super.GameTableStream(message, metadata, options);
    };
    GetPlayerID: GrpcUnaryServiceInterface<dependency_1.google.protobuf.Empty, PlayerID> = (message: dependency_1.google.protobuf.Empty, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<PlayerID>, options?: grpc_1.CallOptions | grpc_1.requestCallback<PlayerID>, callback?: grpc_1.requestCallback<PlayerID>): grpc_1.ClientUnaryCall => {
        return super.GetPlayerID(message, metadata, options, callback);
    };
    MessageStream: GrpcStreamServiceInterface<JoinRoomRequest, JoinRoomRequest> = (message: JoinRoomRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<JoinRoomRequest> => {
        return super.MessageStream(message, metadata, options);
    };
    OperatorsStream: GrpcStreamServiceInterface<JoinRoomRequest, JoinRoomRequest> = (message: JoinRoomRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<JoinRoomRequest> => {
        return super.OperatorsStream(message, metadata, options);
    };
    Operate: GrpcUnaryServiceInterface<Operator, dependency_1.google.protobuf.Empty> = (message: Operator, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<dependency_1.google.protobuf.Empty>, options?: grpc_1.CallOptions | grpc_1.requestCallback<dependency_1.google.protobuf.Empty>, callback?: grpc_1.requestCallback<dependency_1.google.protobuf.Empty>): grpc_1.ClientUnaryCall => {
        return super.Operate(message, metadata, options, callback);
    };
}
